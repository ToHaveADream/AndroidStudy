# 深入 JVM--Java 垃圾回收机制最全解析

深入理解 Java  的GC 机制，不仅有助于我们在开发中提高程序的性能，更有了在面试官面前炫技的技术。本篇文章将全面深入的分析 JVM 的垃圾回收机制，同时还会对常用的垃圾收集器（包括最前沿的 ZGC 收集器 和 Shenandoah 收集器）进行讲解。

## 一、GC 机制概述

我们知道对象的创建时由 JVM 完成的，在对象创建的时候 JVM 会在 Java 堆中开辟一块空间用来存储这个对象。当对象死亡的时候，同样是由 JVM 来处理的，JVM 处理死亡的对象的过程就是垃圾回收机制。

#### 1、堆内存的区域划分

关于堆内存的区域的划分，其实是由垃圾收集器的特性决定的。本节将要讲到的内存区域划分主要是指的 G1 收集器之前的经典垃圾收集器对堆内存的划分。

为了 JVM 更好的管理和回收对象，Java 的设计者们将 Java 的堆内存划分成了两大块，分别为：**新生代（young generation) 和 老年代（Old Generation）**。而根据新生代的特性，又将新生代分为了一块较大的 Eden 区域和两块较小但大小相等的 Survivor 区域。至于新生代和老年代这两块区域，是我们今天要探讨的重点。

了解了堆内存的划分之后我们再来看垃圾回收的特点。垃圾收集器在执行一次垃圾回收时，可能是**部分收集（Partical GC)也可能是整堆收集（FULL GC），**部分收集又可以分为**新生代收集（Minor GC/Young GC）和老年代收集（major GC/Old GC）**。既然有这样的划分，那收集器回收区域的规则是根据什么条件确定的呢？在 JDK6 update 24 之后，回收区域的规则为：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。

对象通常是在 Eden 区域被创建，JVM 会给每个对象定义一个年龄（Age）计数器，存储在对象头中。如果经过第一次 Minor GC后对象仍然存活，并且能被 Survivor 区域容纳的话，对象则会被移动到 Survivor 区域，同时会将对象的年龄设置为1岁。接下来，该对象会经历多次的垃圾回收，Survivor 区中的对象每熬过一次 Minor GC，他的年龄就会增加一岁。如果这个对象增加到一定年龄（默认15，可通过 -XX：MaxTenuringThreshold 参数设置），就会被移动到老年代中。

当然，为了更好的适应不同程序的内存情况，HotSpot 虚拟机并不是绝对要求对象年龄达到 -XX:MaxTenuringThreshold 后才能转移到老年代，特殊情况有两种：

- Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象就可以直接进入老年代。
- 另外，对于大对象，HotSpot 虚拟机可通过 -XX:PretenureSizeThreshold 参数进行设置，当对象内存大于设定的值的话，这个对象会绕过 Eden 区域直接被分配到老年代。

### 2、永生代（Permanent Generation）

在 JDK7以及之前，HotSpot 虚拟机还有另外一块叫**永生代（Permanent Generation）**的存储区域，这块区域并不属于堆内存，而是对于方法区的实现。主要用来存放Class 和 Meta（元数据）的信息，Class 在类加载的时候被放入永生代。永生代和存放实例的堆内存不同，GC 不会在主程序运行期间对永生代进行清理，所以这也导致了永生代的区域会随着加载的 Class 的增多而爆满，最终抛出异常。

虽然被称为永生代，但这块内存区域也会进行垃圾回收。永生代的垃圾回收主要包括废弃常量和无用的类（被类加载器卸载的 Class）。永生代触发垃圾回收的条件比较困难，需要同时满足以下三点：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的实例
- 加载该类的 ClassLoader已经被回收
- 该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法

### 3、元空间（MetaSpace)

由于永生代可能存在内存溢出的问题，在 JDK8之后永生代已经不复存在，取而代之的是**元空间（MetaSpace）**。

元空间的本质和永生代类似，**都是对 JVM 规范中方法区的实现**。不过元空间和永生代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过 -XX:MetaSpaceSize 这个参数来指定初始空间大小，当达到设置的最大值就会触发垃圾收集进行类型卸载，同时 GC 会对该值进行调整；如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 MaxMetaSpaceSize 时，适当提高该值。可以通过 -XX:MaxMetaspaceSize 来设置元空间能够使用的最大内存，默认是没有限制的。

除了上面两个指定大小的选项以外，还有两个 GC 相关的属性：

XX：MinMetaspaceFreeRatio，在GC 之后，最小的 MetaSpace 剩余空间容量的百分比，减少为分配空间所导致的垃圾收集  

-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集

有关垃圾回收的区域如下所示：

![](/picture/data-05.image)

上图中的 Permanent Generation 区域，在 JDK8 中，被 MetaSpace 区域取代了。

## 二、垃圾收集的标记算法

垃圾收集器回收垃圾的第一步先要确定哪些对象是可以被回收的。因此，JVM 会扫描堆内存中的所有对象，并标记出可以回收的对象，而垃圾收集的标记算法有以下两种：

#### 1、引用计数算法

应用计数算法通过在每个对象中添加一个计数器，当有一个地方引用它的时候计算器的值就会增加1；当引用失效的时候计数器的值就会减1.当计数器的值为0的时候，则可认为这个对象已经不再使用。因此对于引用计数算法，垃圾收集器只需要回收计算器为0的对象即可。

引用技术算法的优点是效率很高，不需要遍历所有对象。但它存在一个致命的缺点，即无法解决对象之间循环引用的问题。比如对象A 引用了对象 B，对象B 也引用了对象A，除此之外，A、B 两个对象再也没有被其他地方引用。此时对象 A 和对象B 的引用计数器均不为0，所以 A、B 两个对象都无法被回收，所以，目前商用的 Java 虚拟机都没有选用引用计数法来进行标记。

#### 2、可达性分析法

可达性分析算法也被称为根搜索算法。这一算法的基本思路是用一系列的 “GC Roots" 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径被称为”引用链“（reference chain)。如果一个对象到 GC Roots 没有任何的引用链相连，则证明此对象可能不再被使用。

如下图所示，灰色部分的对象没有关联到引用链上，此时这些对象就会被判定为可回收对象。

![](/picture/data-06.image)

哪些对象可以被称为 GC Roots呢？主要包括如下几种：

- 在虚拟机栈中引用的对象（栈帧中的本地变量表）
- 方法区中类静态变量引用的对象
- 在方法区中引用的对象，如字符串常量池（String Table）里引用的对象
- 本地方法栈中 JNI 引用的对象
- Java 虚拟机中内部的引用，如基本数据类型对应的 Class 对象以及一些常驻的异常对象等
- 所有同步锁持有的对象
- 反应虚拟机内部情况的 JMXBean、JVMTI 中注册回调、本地代码缓存等

## 三、垃圾收集的算法

### 1、标记-清除算法（Mark-Sweep）

标记-清除算法是最早出现也是最基础的一种垃圾收集算法。该算法分为标记和清除两个阶段，标记阶段就是上边讲到的对垃圾的标记。首先会通过可达性分析算法标记处所有需要回收的对象，然后同一回收掉所有被标记的对象。标记--清除算法的执行过程如下图所示：

![](/picture/data-07.image)



图中深灰色区域为可回收区域，在标记完成后直接将可回收区域进行清理。这一算法很容易理解。理解起来也很便捷，但是有两个缺点：

- 执行效率会随着对象增多而降低。如果 Java 堆中包含大量需要回收的对象。此时需要进行大量标记和清除操作。导致标记和清除这两个过程需要大量的时间，降低了执行效率。
- 引起严重的内存碎片化问题。标记、清除之后会产生大量不连续的内存空间，这可能会导致在需要分配大对象的时候无法找到连续的空间，进而引发 GC。

#### 2、标记-复制算法（Copying）

标记-复制算法也被称为复制算法。它是对标记-清除算法的改进。它是对标记-清除算法的改进。复制算法将内存划分为大小相等的两块，分配算法时只使用其中的一块。当这块内存使用完时，就将存活的对象复制到另外一块上面，然后把已使用的这块内存一次性清理掉。复制算法的执行过程如下所示：

![](/picture/data-08.image)

复制算法虽然解决了标记-清除算法的一些问题，但是缺陷也显而易见，直接导致了可用内存变为原来的一半，使用效率降低。

#### 3、标记-整理算法（Mark-Compact）

标记整理算法在标记了存活对象之后，会让所有存活对象向内存的一端移动，然后直接清除掉边界外的内存。该算法的示意图如下所示：

![](/picture/data-09.image)

移动存活对象并更新所有被移动对象的引用是一个比较耗时的操作。而且，在移动对象时必须暂停所有用户线程才能进行（有一个专有名词叫做“Stop the World",简称 STW）。拖累了用户程序执行的效率。

#### 4、分代收集（Generational Collection）

分代收集不能算得上是一种算法，他会根据堆内存的不同区域采用不同的收集算法。

比如上边我们说过的，在 G1 收集器之前，所有的收集器都是将 Java 堆分为新生代和老年代，由于新生代中对象成活率比较低，因此在新生代采用了优化的复制算法。HotSpot 虚拟机中将 Eden 和 Survivor 的大小划分为 8:1 的比例，分配对象只使用 Eden 和其中的一块区域，在标记完成后将存活的对象复制到另外一块 Survivor 空间中，然后清除 Eden 和使用的一块 Survivor。这样，新生代的空间利用率就达到了 90%。

对于老年代每次垃圾回收存活的对象比较多，因此采用的是标记-整理算法进行垃圾回收。

### 四、垃圾收集器

垃圾收集器其实就是前面讲到的原理的实现。垃圾收集器一直在进行改进，Oracle JDK15 中又引入了新的垃圾收集器 Shenandoah。直到今天 Java 的设计者们依然在对收集器进行优化。

我们先来看一下经典的几款垃圾收集器，图中连线表示这两款收集器可以配合使用。

![](/picture/data-10.image)

### 1、新生代收集器

#### 1.1 Serial 收集器

Serial 收集器是最基础、发展历史最悠久的收集器。他是一个单线程工作的收集器，对于早期的单核处理器或处理器核心数较少的情况下，Serial 收集器由于没有线程交互的开销，所有收集效率比较高。但是，Serial 收集器整个收集过程是需要 STW 的。这也是导致早期 Java 程序程序慢的主要原因之一。Serial 收集器新生代采用的标记-复制算法，运行过程如下图所示：

![](/picture/data-11.image)

#### 1.2 ParNew 收集器

ParNew 收集器实质上是 Serial 收集器的多线程版本。除了使用多条线程进行垃圾收集之外，其他特性包括 Serial 收集器的所有控制参数、收集算法、Stop the World、对象分配原则、回收策略等都与 Serial 收集器完全一致。ParNew 收集器的工作过程如下图所示：

![](/picture/data-12.image)

ParNew 是 JDK7 之前的遗留系统中首选的新生代收集器，因为除了 Serial 收集器外它是唯一能和 CMS 收集器配合工作的新生代收集器。

#### 1.3 Parallel Scavenge 收集器

Parallel Scavenge 收集器也是一款新生代收集器，它同样是基于标记-复制算法实现，也是能够并行收集的多线程收集器，从表面上看它和 ParNew 非常相似。Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量（Throughput）。

> 吞吐量=（用户运行代码的时间）/ （运行用户代码时间 + 运行垃圾收集时间）

Parallel Scavenge 收集器运行过程如下图所示：

![](/picture/data-13.image)

### 2. 老年代收集器

#### 2.1 Serial Old 收集器

Serial Old 是 Serial 收集器的老年代版本，它与 Serial 一样都是单线程收集器。Serial Old 使用的时标记-整理算法。它的主要意义也是提供客户端模式下的 HotSpot 虚拟机使用。

#### 2.2 Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法。这个收集器是在 JDK 6时开始提供。

#### 2.3  CMS 收集器

CMS（Concurrent mark Sweep）收集器是一款具有划时代意义的收集器。前面我们提到的几款收集器在工作期间需要 STW，而 CMS 第一次实现了垃圾收集的并发处理。因此，这款收集器可以有限的减少垃圾收集过程中的停顿时间。CMS 收集器是基于标记-清除算法实现的。我们开详细了解一下 CMS 的工作过程：

- **初始标记**：从 GC Roots 出发标记全部直接直接子节点的过程，该阶段是 STW 的。由于  GC Roots 的数量不多，通常该阶段耗时非常短。
- **并发标记**：并发标记阶段是指从 GC Roots 开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和 GC 线程可以同时活动，并发标记耗时相对长很多，但因为不是 STW ，所以我们不太关心该阶段耗时的长短。
- **重新标记**：重新标记那些在并发标记阶段发生变化的对象。该阶段是 STW 的。
- **并行清理**：并行清理，开启用户线程，同时 GC 线程开始对标记的区域做清扫。

CMS 运行过程如下图所示：

![](/picture/data-14.image)

从上面的藐视可以看到。CMS能够并发收集，有限减少停顿时间，但 CMS 并不是一款完美的垃圾收集器，不然也不会在 JDK15中将其移除。它的缺点主要有几个：

- **并发收集占用 CPU 资源**。虽然并发阶段不会导致用户停顿，并发时的收集线程却占用了一部分 CPU 资源，导致应用程序变慢，降低了吞吐量。
- **无法处理浮动垃圾**。CMS 的并发标记和并发清理阶段，用户线程是继续运行的，这期间必然会有新的垃圾对象产生。对于已经收集过的区域，CMS 无法再去回头处理它们，只能等到下一次垃圾收集时再清理掉。
- **并发清理阶段需要保证内存充足**。由于在垃圾收集阶段用户线程依然在运行，所以不得不预留足够的空间给用户线程使用。因此 CMS　收集器在垃圾收集开始时需要预留足够的内存。JDK 5的默认设置，当老年代使用了68%的空间后，垃圾收集会被激活。虽然可以通过参数 -XX:CMSInitiatingOccupancyFraction 来调高 CMS 的触发百分比，但这样又会导致 CMS 运行期间可能出现预留内存不足的情况。此时，CMS 就会出现一次“并发失败”（ConcurrentMode Failure），虚拟机不得不启动后备预案，停止用户线程执行，启动 Serial Old 收集器重新进行老年代的收集。
- **产生大量内存碎片**。由于 CMS 使用的时 “标记-清除”算法，因此会导致大量空间碎片产生。

### 3.全局收集器

#### 3.1 Garbage First 收集器

Garbage First 收集器简称为 G1收集器，他在 JDK6 中被添加到 HotSpot 虚拟机中的。与其他收集器相比 G1 收集器引入了很多新特点。如下：

1）**独具特色的分代收集方式**

G1 收集器在堆内存的分代上做了很大的改变。它不再将堆内存简单的分为新生代和老年代，而是将堆划分为若干个相等大小、内存连续的 Region。每个 Region 都可以根据需要扮演 Eden 空间、Survivor 空间、Old 空间 或者 Humongous。如下图所示：

![](/picture/data-15.image)

其中 Humongous 区域我们比较陌生，它是 G1 收集器独有的用于存放大对象的区域。如果对象的大小超过了 Region 容量一半，即被判定为大对象放入 HumonGous 空间。如果一个非常大的对象超过了整个 Humongous的内存，则这个对象会被存放在 N 个连续的 Humougous Region 之中。这么看来，Humougous 更像是分担部分老年代的功能。

> Region 的大小可以通过参数 -XX:G1HeapRegionSize 设置，取值范围是 1~ 32MB，且应该为 2 的 N 次幂

当然，别具一格的分代方式也会带来别具一格的问题。垃圾收集器应该如何跨Region 进行收集？因为一个对象被分配到某个 Region 中，这个对象不可能只被本 Region 的对象引用，而是可能与 堆中任意一个 Region 中的对象建立引用关系。这种情况其实在新生代和老年代一样会遇到，只不过在 G1 中更加的明显。对于这种问题的处理虚拟机都是使用 Remembered Set 来避免全堆扫描的。在 G1 的每个 Region区都维护着一个 Remembered Set 来避免全堆扫描的。当虚拟机发现程序在堆引用类型的数据进行写操作时会产生一个写屏障（Write Barrier），检查引用的对象是否处于不同的 Region。如果是，则通过 CardTable 将引用信息记录到被引用对象所属的 Region 的 Remember Set 中。当垃圾回收启动时，在 GC 根节点的枚举范围中加入 Remember Set 即可保证不可对全堆扫描，同时也不会有遗漏。

> Remember set 在存储结构上是一个 哈希表，Key 是别的 Region的起始地址，Value 是一个集合，里面存储的是 CardTable 的索引号。CardTable 存储的是“我指向谁”，而整个 Remember Set 中的一个键值对（key +  value) 其实构成了一个双向卡表，即“我指向谁，谁指向我”

由于 Region 的数量要比传统的收集器的分代数量要多得多，因此 G1 收集器要比其他传统收集器有更高的内存占用负担。根据经验，G1至少耗费大概相当于 Java 堆容量10% 到 20% 的额外内存来维持收集工作。

2）**能建立可预测的停顿时间模型**。G1 收集器可以有计划的避免整个 Java 堆进行全区域的垃圾收集。他会跟踪各个 Region 里面的垃圾堆积的价值大小，在后台维护一个优先列表（Collection Set），并且允许用户通过 -XX:MaxGCPauseMiiiis 参数设定允许的收集停顿时间。G1 根据设定的停顿时间优先处理回收价值收益最大的那些 Region，这也是 Grabage First 名字的由来。这种使用 Region 划分内存空间以及有优先级堆回收方式保证了 G1 收集器在有限的时间内可以获取尽可能高堆收集效率，但是这个停顿时间必须切合实际，如果设置的很低，会导致每次只能回收很小的一部分内存，最终垃圾慢慢堆积，占满整个内存，导致 Full GC 而产生长时间的 STW，影响性能。

3）**具有整合空间碎片的能力**。G1 收集器从整体来看是基于“标记-整理”算法实现的，从局部（两个Region）是基于“复制”算法来实现的，这两种算法在执行期间都不会产生内存碎片。

4）**可以并行和并发收集**。G1 收集器的运作过程可以分为四个步骤：

**初始标记**：初始标记只会标记 GC Roots 能直接关联到的对象，这一阶段是需要 STW 的，由于 GC ROOTS 数量有限，所以这一阶段不会消耗太多的时间。

**并发标记**：从 GC Roots 开始对堆中对象进行可达性分析，找出存活对象。并发标记阶段耗时较长，但是这一阶段是并发执行的，因此，不会对性能造成影响

**最终标记**：重新标记在并发阶段发生变化的对象，这一阶段是需要 STW 的，但耗时很短。

**筛选回收阶段**：负责更新 Region 的数据，对各个 Region 的回收成本进行排序，根据用户所期望的停顿时间来指定回收计划。可自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉旧 Region 的全部空间。这里涉及到存活对象的移动必须是 STW 的，由多个收集器线程并行完成。

收集过程如下：

![](/picture/data-16.image)

### 3.2 ZGC 收集器

ZGC 收集器是目前为止垃圾收集器最前沿的成果（Java11），它针对目标是大内存、低延迟的后端服务器。ZGC可以将 T 级别内存回收的停顿时间控制在 10 ms 以内，并且停顿时间不会随着内存的增大而增大。ZGC 能有这样的成果主要得益于它使用了读屏障、染色指针、多重映射技术，实现了可并发的标记--整理算法。

##### 1）ZGC 的堆内存划分

ZGC 与 G1  收集器类似，都是将堆内存划分成了许多的 Region。但与 GC 不同的是，ZGC 的 Region 区域大小是不相等的，且具有动态创建和动态销毁的特性。ZGC 将Region 分为 大中小三类容量。其中，小型 Region 的容量固定 2MB，用于存放内存小于256k 的小对象；中型 Region 容量固定为 32 MB，用于存放大小大于等于 256KB 但小于 4MB 的对象；而大型 Region 的容量不固定，但必须是 2MB 的整数倍（N 大于 2），用来存储大于 4MB 的对象。大 Region 容量不固定的这一特性也导致了他的内存可能比中型 Region 还小的情况。

ZGC 的堆内存划分如下图所示：

![](/picture/data-17.image)

2) **ZGC 的关键技术**



以 HotSpot 为例，来分析一下 GC 的主要过程：

刚开始时，对象分配在 Eden 区，s0 （即 From） 及 s1 （即to）区，几乎都是空着。

![](/picture/640.webp)

随着应用的运行，越来越多的对象被分配到 Eden 区。

![](/picture/641.webp)

当 Eden 区间放不下时，就会发生 minor GC （yong GC),第一步当然是要先标记出不可达垃圾对象，然后将可达对象，移动到 S0 区，然后将黄色的垃圾块清理掉，这一轮过去，Eden 区就成空的了。这里使用了标记-清理  eden 和 标记-复制算法 Eden -> s0 算法。

![](/picture/642.webp)

随着时间的推移，Eden 如果又满了，再次触发 Minor GC，同样还是先做标记，这时 Eden 和 S0 区可能都有垃圾对象了（黄色块），注意：这时s1  区是空的，s0 区和 Eden 区的存活对象，将直接搬到 S1 区。然后将 Eden 和 s0 的垃圾清理掉，这一轮 minor GC 之后，Eden 和 s0 区就变成空的了。

![](/picture/643.webp)

继续，随着对象的不断分配，Eden 可能又满了，这时会重复刚才的 Minor GC 过程，不过需要注意的时，这时候 S0 是空的，所以 S0 和 S1 的角色其实会互换，即：存活的对象，会从 Eden 和 S1 区，向 S0区进行移动，然后把 Eden 和 S1 区的垃圾清除，这一轮过后，Eden 与 S1 区变成空的，如下图:

![](/picture/644.webp)

对于那些比较“长寿”对象一直在 S0 与 S1 中挪来挪去，一直很占地方，而且会造成一定开销，降低 GC 效率，于是有了“代龄（age）”及“晋升”。

对象在年轻代的3个区（edge，s0，S1）之间，每次从1个区移到另一区，年龄+1，在 young 区达到一定的年龄阈值之后，将晋升到老年代。下图中是8，即：挪动8次后，如果还活着，下次 Minor GC时，将移动到 Tenured 区。

![](/picture/645.webp)

下图是晋升的过程：对象先分配在年轻代，经过多次 Young GC 后，如果对象还活着，晋升到老年代。

![](/picture/640.png)

如果老年代，最终也放满了，就会发生 major GC（即 Full GC），由于老年代的对象通常会比较多，因为标记-清理-整理（压缩）的耗时通常会比较长，会让应用出现卡顿的现象，这也是为什么很多应用要优化，尽量避免或减少 Full GC 的原因。

![](/picture/641.png)

> 上面的过程主要来自 Oracle 官网的资料，但是有一个细节官网没有提到，如果分配的新对象比较大，Eden 放不下，但是 old 区可以放得下，会直接分配到 old 区（即没有晋升的过程，直接到老年代了）

![](/picture/646.webp)



#### 如何解决元空间的内存溢出问题呢？

元空间主要是存储类的元数据信息，我们的应用里加载的各种描述信息，比如类名、属性、方法、访问限制等，按照一定的结构存储在 MetaSpace 里面。MetaSpace 的大小和加载类的数据有关系，加载的类越多 MetaSpace 占用的内存越大。（使用反射类加载，动态代理生成的类过多会导致 MetaSpace 空间过大）。

默认情况下，元空间的大小仅受本地内存限制，但是为了整体的性能，尽量还要对该项进行设置，避免造成整机的服务停机。

- 优化参数设置，避免影响其他 JVM 进程

  -XX:MetaSpaceSize，初始化空间大小,达到该值就会触发垃圾收集进行类型卸载，同时 GC 会对该值进行调整，如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么就在不超过 MaxMetaSpaceSize 时，适当提高该值。

- 慎重引用第三方包

  对第三方包，一定要慎重选择，不需要的包就去掉。这样有助于提高编译打包的速度，也有助于提高远程部署的速度

- 关注动态生成类的框架

  对于使用大量动态生成类的框架，要做好压力测试，验证动态生成的类是否超过内存的需求而抛出异常

开始进行标记前，需要先暂停应用线程，否则如果对象一直在变化的话是无法区遍历的，暂停应用线程以便 JVM 可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point），这会触发一次 STW暂停。触发安全点的原因有很多，但最常见的就是垃圾回收了。

安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的。长时间执行 的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等等，所以具有这些功能的指令才会产生安全点。对于安全点，另外一个需要考虑的问题就是如何在 GC 发生时让所有线程都“跑”到最近的安全点上再停顿下来。两种解决方案：

- 抢先式中断。抢先式中断不需要线程的执行代码主动配合，在GC 发生时，首先把所有线程全部中断，如果有发现线程不在安全点上面，就恢复线程，让它跑到安全点上。现在没有这样做的
- 主动式中断：主动式中断的思想是当 GC 需要中断线程的时候，不直接对 线程操作，仅仅简单设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的。另外再加上创建对象需要分配内存的地方。

**在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：**

- 如果对象在进行根搜索后发现没有与根对象相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 `finalize()`方法（可看作析构函数，类似于 OC 中的`dealloc`，Swift 中的`deinit`）。当对象没有覆盖`finalize()`方法，或`finalize()`方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。
- 如果该对象被判定为有必要执行`finalize()`方法，那么这个对象将会被放置在一个名为`F-Queue`的队列中，并在稍后由一条由虚拟机自动建立的、低优先级的`Finalizer`线程去执行`finalize()`方法。`finalize()`方法是对象逃脱死亡命运的最后一次机会（因为一个对象的`finalize()`方法最多只会被系统自动调用一次），稍后 GC 将对`F-Queue`中的对象进行第二次小规模的标记，如果要在`finalize()`方法中成功拯救自己，只要在`finalize()`方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。

分别为：

- **强引用（Strong Reference）**：如`Object obj = new Object()`，这类引用是 Java 程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。
- **软引用（Soft Reference）**：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2 之后提供了`SoftReference`类来实现软引用。
- **弱引用（Weak Reference）**：它也是用来描述非必须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK1.2 之后，提供了`WeakReference`类来实现弱引用。
- **虚引用（Phantom Reference）**：也称为幻引用，最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2 之后提供了`PhantomReference`类来实现虚引用。

#### 分代存储的对象特点

特别地，在分代收集算法中，对象的存储具有以下特点：

1. 对象优先在 Eden 区分配。
2. 大对象直接进入老年代。
3. 长期存活的对象将进入老年代，默认为 15 岁。

对于晋升老年代的分代年龄阈值，我们可以通过`-XX：MaxTenuringThreshold`参数进行控制。在这里，不知道大家有没有对这个默认的 15 岁分代年龄产生过疑惑，为什么不是 16 或者 17 呢？实际上，HotSpot 虚拟机的对象头其中一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit，官方称它为`Mark word`。

例如，在 32 位的 HotSpot 虚拟机中，如果对象处于未被锁定的状态下，那么`Mark Word`的 32bit 空间中 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0，其中对象的分代年龄占 4 位，也就是从`0000`到`1111`，而其值最大为 15，所以分代年龄也就不可能超过 15 这个数值了。

#### GC 分类的特点

除此之外，我们再来简单了解一下 GC 的分类：

- **新生代 GC（Minor GC / Scavenge GC）**：发生在新生代的垃圾收集动作。因为 Java 对象大多都具有朝生夕灭的特性，因此 Minor GC 非常频繁（不一定等 Eden 区满了才触发），一般回收速度也比较快。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集。
- **老年代 GC（Major GC / Full GC）**：发生在老年代的垃圾回收动作。Major GC 经常会伴随至少一次 Minor GC。由于老年代中的对象生命周期比较长，因此 Major GC 并不频繁，一般都是等待老年代满了后才进行 Full GC，而且其速度一般会比 Minor GC 慢10倍以上。另外，如果分配了 Direct Memory，在老年代中进行 Full GC 时，会顺便清理掉 Direct Memory 中的废弃对象。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”算法或“标记-整理”算法来进行回收。

#### CardTable 的由来

 再多说一句，在某些场景下，老年代的对象可能引用新生代的对象，那标记存活对象的时候，需要扫描老年代中的所有对象。因为该对象拥有对新生代对象的引用，那么这个引用也会被称为`GC Roots`。那是不是要做全堆扫描呢？成本也太高了吧?

HotSpot 给出的解决方案是一项叫做卡表（`Card Table`）的技术，该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。

在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的`GC Roots`里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。

想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。

卡表能用于减少老年代的全堆空间扫描，这能很大的提升 GC 效率。

#### JDK8使用的垃圾收集器

JDK 8 默认打开了`UseParallelGC`参数，因此使用了`Parallel Scavenge + Serial Old`的收集器组合进行内存回收。

- 字符串存放在永久代中，容易出现性能问题和内存溢出问题
- 类和方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易导致内存溢出，太大会导致老年代溢出















