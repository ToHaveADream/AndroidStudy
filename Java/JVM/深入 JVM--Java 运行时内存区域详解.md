# 深入JVM -- Java 运行时内存区域详解

Java 内存分配是 Java 基础中非常重要的一环，深入了解 Java 内存分配机制有助于我们了解开发中遇到的很多的问题。

## JVM 内存分配概述

不同的虚拟机在内存分配上也略有差异，但是总体来说都遵循 Java 虚拟机规范，本规范规定了五中虚拟机运行时的数据区，他们分别是：程序计数器、方法区、虚拟机栈、本地方法栈、堆。如下图所示：

![](/picture/data-01.image)

## 1、程序计数器（Program Counter)

程序计数器是用于存放下一条指令所在单元地址的一块内存，在 Intel x86 和 Itanium 微处理器中，被称作 指令指针（instruction pointer ,IP)，显然“指令指针”这个名字更易于我们理解这个概念。在 JVM 中，程序计数器是一块较小的内存空间，可以看做是**当前线程所执行字节码的行号指示器**。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器完成。

我们知道，多线程的情况下，线程是由 CPU 调用来执行指令的，在单核 CPU 中，某一时刻只会有一个线程在执行命令，这意味着 CPU 会频繁的切换线程，而在线程切换后需要恢复到正确的执行位置，着就需要**每条线程都有一个独立的程序计数器**，各个线程之间互不影响。

另外，关于程序计数器我们需要知道的时，Java 虚拟机规范中没有针对程序计数器规定任何的 OutMemoryError。至于为什么？我觉得应该是程序计数器所占用的内存很小，加上线程是有限的。因此，没有做任何约束限制。因此，得出以下几点总结：

- 程序计数器是线程私有的，每条线程都有一个程序计数器
- 程序计数器中存放了下一条要执行的指令的位置
- 字节码解释器通过改变计数器的值来执行命令
- 程序计数器是 JVM 内存中唯一没有规定 OutMemoryError 的区域

## 二、Java 虚拟机栈（Java Virtual Machine Stack)

提到 Java 中的栈内存，大家应该都不陌生，甚至很多同学对于栈内存说的头头是道：“栈内存是用于存储基本数据类型和对象的引用的”。但是，这仅仅是 Java 虚拟机栈功能的一部分。

虚拟机栈描述的是 Java 方法执行时的内存模型：每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法返回等信息。每一个方法从调用知道执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

而我们平时所说的“栈内存”其实指的是虚拟机中的局部变量表部分。局部变量表存放了编译器可以知道的各种数据类型（boolean、type、char、short、int、final、long、double）、对象引用（reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令地址），其中长度为 long 和 double 类型的数据会占用两个局部变量空间（slot），其余的数据类型只占用一个。而局部变量表所需要的的空间是在编译期间完成分配的，当进入一个方法时这个方法所需要在栈帧中分配多大的局部变量空间是完全可以确定的，在方法的运行期间不会改变局部变量的大小。

同时，Java 虚拟机栈与程序计数器一样都是线程私有的。Java 虚拟机栈的生命周期与线程相同。另外，在 Java 虚拟机规范中对这一区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出 StackOverFlowError 异常；如果虚拟机栈可以动态扩展（当前大部分的虚拟机都可以动态扩展）如果扩展时无法申请到足够的内存则会抛出 OutOfMemoryError 异常）。

得出以下几点结论：

- 虚拟机栈是线程私有的，生命周期与线程相同
- 虚拟栈的功能不仅仅是存储基本数据类型和对象引用
- 虚拟机栈描述的是 Java 方法运行时的内存模型
- Java 虚拟机栈内存不足时会抛出 StackOverflowError 异常 和 OutOfMemoryError 异常

## 三、本地方法栈（Native Method Stack)

本地方法栈与虚拟机栈的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用的方式与数据结构并没有强制的规定，因此虚拟机是可以自由实现的，像 Hotspot 虚拟机就把 本地方法栈和虚拟机栈合二为一了。

与虚拟机栈一样，本地方法栈区域也会抛出 StackOverFlow 和 OutOfMemoryError。

关于本地虚拟机栈，我们有如下总结：

- 本地方法栈为虚拟机使用的 Native 方法服务
- 某些虚拟机本地方法栈和虚拟机栈合二为一
- 本地方法栈区域会抛出 StackOverFlowError 和 OutOfMemoryError

## 四、Java 堆

堆内存应该是 Java 开发者最熟悉的一块内存区域了，因为它实在是太重要了。我们创建的对象实例几乎都是存放在堆内存中的。因此，Java 堆是虚拟机所管理的最大的一块内存区域了。**Java 堆是所有的线程共享的一块内存区域**，在虚拟机启动的时候创建。Java 虚拟机规范中对堆内存有这样的描述：**所有的对象实例以及数组都要在堆上面分配**，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化，所有的对象都在堆上分配也不是那么绝对了。

对于 Java 堆内存我们还可以进行一个细分：**新生代（young Generation)、老年代（old Generation);**而新生代则又可以细分为 Eden 空间、From Survivor 空间、To Survivor。如下图所示（注：图片中 Permanent Generation 即永生代不属于堆内存，而是方法区的一部分）：

![](/picture/data-02.image)

而 Java 中的垃圾回收就是针对 Java 堆上不同的区域进行扫描回收。

从内存分配的角度来看，堆上共享的 Java 堆中可能划分出多个线程私有的缓冲区(Thread Local Allocation Buffer,TLAB)。

但是，无论怎么划分，堆上锁存放的内存都是对象的实例。进一步划分只不过是为了更好的回收内存或者更宽的分配内存。

另外，Java 虚拟机规范中规定，Java 堆可以处于物理上不连续的内存空间中。如果虚拟机在为实例分配空间的时候没有足够的空间，并且堆也无法扩展，则会抛出 OutofMemoryError 异常。

关于 Java 堆我们可以做如下总结：

- 堆内存是被线程共享的一块内存区域
- Java 中创建的对象几乎都放在堆内存中
- 垃圾回收机制会堆内存进行扫描和垃圾回收对象的回收
- 堆内存不足时会抛出 OutOfMemoryError 异常

## 五、方法区（Method Area)

方法区是用来存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区和堆内存一样是线程共享的一块区域。Java 虚拟机对于方法区的限制非常宽松，因此也导致了不同的虚拟机上方法区有不同的表现。我们以 HotSpot 虚拟机为例：**方法区在 JDK 1.7 之前是一块单独的区域**，很对人喜欢把它称为：永生代；但是本质上两者并不等价，仅仅是因为 HotSpot 虚拟机的设计团队把 GC 分代收集扩展到了方法区，或者说**使用永久代来实现了方法区**。这样HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存，但是对于其他虚拟机来说其实是不存在永生代的概念的，用永生代来实现方法区也不是一个好主意，因为容易出现内存溢出的问题，因此，在 JDK1.7 中讲方法区的字符串常量池移到了堆内存中，并在 JDK1.8中完全废除了“永生代”，使用**元空间**替代了永生代。

另外，根据 Java 虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。

关于方法区有如下总结：

- 方法区与堆内存一样是所有线程共享的一块区域
- 方法区是用来存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- 不同的虚拟机对于方法区的实现不同
- HotSpot 虚拟机在 JDK 1.7 将字符串常量池移到了堆内存，并在 JDK 1.8中用元空间去掉了“永生代”
- 方法区内存不足时会抛出 OutOfMemoryErro 异常

## 六、Java 中的常量池

关于常量池Java 可以分为三种，分别为：全局字符串常量池、Class 文件常量池、运行时常量池。下面分析一下：

#### 1、字符串常量池（String Pool）

我们知道，字符串属于引用数据类型，但是可以说字符串是 Java  中使用最频繁的一种数据类型。因此，为了节省程序内存，提高性能，Java 的设计者开辟了一块叫字符串常量池的区域，用来存储一些全局的字符串。字符串常量池是所有类公用的一块空间，在一个虚拟机中只有一块常量池区域。在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串实例的引用值存到字符串常量池中（这里描述的是 JDK7及之后的 HotSpot 虚拟机）。在 HotSpot 虚拟机中字符串常量池是通过一个 StringTable 类来实现的。他是一个哈希表，里面存的是字符串引用。我们在上一节提到过，在 JDK1.7 之前，字符串常量池在方法区中（永生代）中，此时常量池中存放的是字符串对象。而在 JDK1.7 中，字符串常量池从方法区迁移到了堆内存，同时将字符串对象存到了堆内存，只在字符串常量池存入了字符串对象的引用。

#### 2、Class 文件常量池（Class Constant Pool)

我们知道，Java 文件在通过 javac 编译后会生成 Class 文件，Class 文件中除了存放类的版本、字段、方法、接口等描述信息外，还有一项是**常量池**，常量池用于存放编译器间生产的各种字面量和符号引用。

#### 3、运行时常量池（Runtime Constant Pool)

运行时常量池是方法区的一部分，虚拟机会在类加载之后将存 Class 文件常量池的内容加载到运行时常量池。因此，每一个类都会有一个运行时常量池。运行时常量池相对于 Class 文件常量池有具备动态性。因为 Java 语言并不要求常量一定在编译期间才能生成，也就是并非预置入 Class 文件常量池中的内容才能进入运行时常量池，运行期间也可以将新的常量放入常量池中，例如 String 类中的 intern()  方法。由于运行时常量池属于方法区，因此其内存限制自然与方法区一样。





















