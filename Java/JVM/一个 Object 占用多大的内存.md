# new Object到底占用多大的字节？

#### 对象的指向

先来看一段代码：

```
package com.zwx.jvm;

public class HeapMemory {
    private Object obj1 = new Object();

    public static void main(String[] args) {
        Object obj2 = new Object();
    }
}
```

上面的代码中，obj1 和 obj2在内存中有什么区别？

obj2 是属于方法区的局部变量，存储在 Java 虚拟机栈内的局部变量表中，这就是经典的栈指向堆：

obj1 是存放在方法区的。属于类的成员变量。JDK8 之后 类的静态成员变量放在了 堆中，属于 Class 对象中。类的元数据才是放在方法区的：方法代码，变量名，方法名，访问权限，返回值等等（即元空间）。JDK8 中 运行时常量池放在 方法区 （元空间中）。

#### Java 内存模型

以64位操作系统为例（未开启指针压缩的情况），Java 对象布局如下图所示：

对象头 + 实例数据 + 对齐填充

64位中内存对齐为 8 字节对齐。

占用字节分析：

new Object（）分析：

- 未开启指针压缩。占用大小：8（mark word) + 8(Class Pointer) = 16字节
- 开启指针压缩（默认开启） 开启指针压缩之后，Class Pointer 会被压缩为 4字节，最终大小为：8（mark word) + 4 (Class Pointer) + 4(字节填充) = 16字节

常量池放到堆里面

# 对象的分配策略，栈上分配和 TLAB

在深入理解虚拟机中一书说：对于大多数的应用来说，Java 堆是 Java 虚拟机锁管理的内存中最大的一块，Java 堆是被所有的线程共享的一块内存区域，在虚拟机启动的时候创建，这里说的是所有。

对 Java 对象分配的过程进行了分析，分析后得知为了解决线程安全问题并且提高效率，有另外两个地方也是可以存放对象的：分别是 栈 和 TLAB。

#### 栈上分配

再问一个问题：如果确定一个对象的作用域不会逃逸出方法之外，那可不可以将这个对象分配在栈上？这样的话，对象所占用的内存空间就可以随着栈帧的出栈而销毁。而且，在一般应用中，不会逃逸的局部对象所占的比例很大，所以如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，无须通过垃圾收集器回收，可以还可以减小垃圾收集器的负载。

分析完以后给出栈上分配官方定义：JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。栈上分配只是JVM虚拟机提供的一种优化技术，对象主要还是分配在堆上的。

栈上分配也是有前提的，并不是所有的对象都可以栈上分配，首先需要进行逃逸分析的，所以逃逸分析是栈上分配的技术基础那什么是逃逸分析呢？逃逸分析是指判断对象的作用域是否有可能逃逸出函数体，关于具体的逃逸分析算法和技术此篇不讨论Java SE 6u23版本之后，HotSpot中默认就开启了逃逸分析，可以通过选项-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果。

#### TLAB（线程本地分配缓冲）

TLAB 的全称是 Thread Local Allocation Buffer，即线程本地分配缓冲区。

##### 为什么需要 TLAB？

创建对象的时候，需要在堆上为新生的对象申请指定大小的内存，如果同时有大量的线程申请内存的话，可以通过锁机制保证不会申请到同一块内存，在 JVM 中，内存分配是一个非常频繁的工作，使用锁会降低性能。

所以出现了 TLAB，JVM 通过使用 TLAB 来避免多线程冲突，每个线程使用自己的 TLAB，可以保证不使用同步，不会出现线程安全，提高了分配的效率。

TLAB本身占用eden区空间，在开启TLAB的情况下，虚拟机会为每个Java线程分配一块TLAB空间。参数-XX:+UseTLAB开启TLAB，默认是开启的。
TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，当然可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。
TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满，就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从TLAB分配出来的，而只关心自己是在eden里分配的。
TLAB空间由于比较小，因此很容易装满。比如，一个100K的空间，已经使用了80KB，当需要再分配一个30KB的对象时，肯定就无能为力了。这时虚拟机会有两种选择，第一，废弃当前TLAB，这样就会浪费20KB空间；第二，将这30KB的对象直接分配在堆上，保留当前的TLAB，这样可以希望将来有小于20KB的对象分配请求可以直接使用这块空间。实际上虚拟机内部会维护一个叫作refill_waste的值，通俗一点来说就是可允许浪费空间的值，当TLAB剩余的空间小于新申请对象的大小，且这个剩余的空间大于refill_waste（可允许浪费空间的值）时，会选择在堆中分配（保留当前的TLAB）；若剩余的空间小于refill_waste（可允许浪费空间的值）时，则会废弃当前TLAB，新建TLAB来分配对象。这个阈值可以使用TLABRefillWasteFraction来调整，它表示TLAB中允许产生这种浪费的比例。默认值为64，即表示使用约为1/64的TLAB空间作为refill_waste。默认情况下，TLAB和refill_waste都会在运行时不断调整的，使系统的运行状态达到最优。

再举两个通俗易懂的例子帮助理解：大家可以花两分钟时间跟着下边的例子算一下，算完后，对refill_waste会有更到位的理解

假设TLAB大小为100KB，refill_waste（可允许浪费空间的值）为5KB
　　1、假如当前TLAB已经分配96KB，还剩下4KB，但是现在new了一个对象需要6KB的空间，显然TLAB的内存不够了，这时可以简单的重新申请一个TLAB，原先的TLAB交给Eden管理，这时只浪费4KB的空间，在refill_waste 之内。
　　2、假如当前TLAB已经分配90KB，还剩下10KB，现在new了一个对象需要11KB，显然TLAB的内存不够了，这时就不能简单的抛弃当前TLAB，因为此时抛弃的话，就会浪费10KB的空间，10KB是大于咱们设置的refill_waste（可允许浪费空间的值）5KB的，所以此时会保留当前的TLAB不动，会把这11KB会被安排到Eden区进行申请。

**运行时常量池**：存在内存的元空间中

**类文件中常量池**：存在于 Class 文件中

**String常量池**：堆中

![](/picture/1.jpg)































































